const mongoose = require('mongoose');
const Workspace = require('../models/workspaceModel');
const Membership = require('../models/memberShipModel');
const User = require('../models/userModel');
const sendEmail = require('../utils/sendMail');
const Board = require('../models/boardModel');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const NotificationService = require('../services/NotificationService');

// L·∫•y workspace m√† user ƒë√£ t·∫°o ho·∫∑c ƒë√£ tham gia, k√®m countBoard
exports.getAllWorkspace = async (req, res) => {
  try {
    const userId = req.user._id;

    // 1. T√¨m t·∫•t c·∫£ membership ƒë√£ accepted c·ªßa ng∆∞·ªùi d√πng
    const memberships = await Membership.find({
      userId,
      invitationStatus: 'accepted',
      isDeleted: false,
    }).select('workspaceId');

    const workspaceIdsFromMembership = memberships.map((m) => m.workspaceId);

    // 2. L·∫•y workspaces (creator ho·∫∑c th√†nh vi√™n)
    //    .lean() ƒë·ªÉ ƒë∆∞·ª£c plain JS object, d·ªÖ g·∫Øn th√™m field
    const workspaces = await Workspace.find({
      isDeleted: false,
      $or: [{ creator: userId }, { _id: { $in: workspaceIdsFromMembership } }],
    })
      .populate('creator', 'username email')
      .populate({
        path: 'members',
        match: { isDeleted: false },
        populate: {
          path: 'userId',
          select: 'username email',
        },
      })
      .lean();

    // 3. V·ªõi m·ªói workspace, ƒë·∫øm s·ªë boards
    const workspacesWithCount = await Promise.all(
      workspaces.map(async (ws) => {
        const count = await Board.countDocuments({
          workspaceId: ws._id,
          isDeleted: false,
        });
        return {
          ...ws,
          countBoard: count, // ‚Üê g·∫Øn th√™m tr∆∞·ªùng countBoard
        };
      })
    );

    return res.status(200).json({
      success: true,
      data: workspacesWithCount,
    });
  } catch (error) {
    console.error('getAllWorkspace error:', error);
    return res.status(500).json({
      success: false,
      error: error.message,
    });
  }
};

// T·∫°o workspace
exports.createWorkspace = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { name, description } = req.body;
    const creatorId = req.user._id;

    if (!name || !creatorId) {
      throw new Error('Thi·∫øu th√¥ng tin name ho·∫∑c creator');
    }

    // 1. T·∫°o workspace
    const [newWorkspace] = await Workspace.create(
      [{ name, description, creator: creatorId }],
      { session }
    );

    // 2. T·∫°o membership cho creator
    const [membership] = await Membership.create(
      [
        {
          workspaceId: newWorkspace._id,
          userId: creatorId,
          role: 'creatorWorkspace',
          invitationStatus: 'accepted',
        },
      ],
      { session }
    );

    // 3. G√°n membership v√†o workspace
    newWorkspace.members.push(membership._id);
    await newWorkspace.save({ session });

    // Commit transaction
    await session.commitTransaction();
    session.endSession();

    res.status(201).json({
      message: 'Create workspace and membership successfully',
      workspace: newWorkspace,
    });
  } catch (error) {
    await session.abortTransaction();
    session.endSession();
    console.error('L·ªói khi t·∫°o workspace:', error);
    res.status(500).json({
      message: 'Create workspace failed',
      error: error.message,
    });
  }
};

// C·∫≠p nh·∫≠t workspace
exports.updateWorkspace = async (req, res) => {
  try {
    const { workspaceId } = req.params;
    const updates = req.body;

    const workspace = await Workspace.findByIdAndUpdate(workspaceId, updates, {
      new: true,
      runValidators: true,
    });

    if (!workspace) {
      return res.status(404).json({ message: 'Workspace not found' });
    }

    res.status(200).json({
      message: 'Update workspace successfully',
      workspace,
    });
  } catch (error) {
    res.status(500).json({
      message: 'Error updating workspace',
      error: error.message,
    });
  }
};

// ƒê√≥ng workspace
exports.closeWorkspace = async (req, res) => {
  try {
    const { workspaceId } = req.params;

    const workspace = await Workspace.findById(workspaceId);
    if (!workspace) {
      return res.status(404).json({ message: 'Workspace is not found' });
    }

    if (workspace.isDeleted) {
      return res.status(400).json({ message: 'Workspace is already closed' });
    }

    workspace.isDeleted = true;
    workspace.deletedAt = new Date();
    await workspace.save();

    res.status(200).json({
      message: 'Workspace is closed successfully',
      workspace,
    });
  } catch (error) {
    res.status(500).json({
      message: 'Error closing workspace',
      error: error.message,
    });
  }
};

// X√≥a workspace
exports.deleteWorkspace = async (req, res) => {
  try {
    const { workspaceId } = req.params;
    console.log('üî• DELETE /workspace/:id hit with', req.params.workspaceId);
    const workspace = await Workspace.findByIdAndDelete(workspaceId);
    if (!workspace) {
      return res
        .status(404)
        .json({ message: 'Workspace not found or already deleted' });
    }

    res.status(200).json({
      message: 'Workspace deleted successfully',
    });
  } catch (error) {
    res.status(500).json({
      message: 'Error deleting workspace',
      error: error.message,
    });
  }
};

// m·ªùi ng∆∞·ªùi d√πng tham gia workspace
exports.inviteMember = async (req, res) => {
  try {
    const { workspaceId } = req.params;
    const { email, role = 'memberWorkspace' } = req.body;
    const inviterId = req.user._id;

    // 1. Ki·ªÉm tra workspace t·ªìn t·∫°i
    const workspace = await Workspace.findById(workspaceId);
    if (!workspace) {
      return res.status(404).json({ message: 'Workspace not found' });
    }

    // 2. T√¨m user theo email
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // 3. Ki·ªÉm tra n·∫øu ƒë√£ l√† th√†nh vi√™n
    const existing = await Membership.findOne({
      workspaceId,
      userId: user._id,
    });
    if (existing) {
      return res
        .status(400)
        .json({
          message: 'User is already a member of the workspace or invited',
        });
    }

    // 4. T·∫°o token m·ªùi
    const token = crypto.randomBytes(32).toString('hex');

    // 5. T·∫°o b·∫£n ghi membership
    const membership = await Membership.create({
      workspaceId,
      userId: user._id,
      role,
      invitationStatus: 'pending',
      invitationToken: token,
    });

    // 6. Kh√¥ng g·ª≠i email n·ªØa, ch·ªâ t·∫°o notification
    // 7. G·ª≠i th√¥ng b√°o real-time sau khi g·ª≠i l·ªùi m·ªùi, truy·ªÅn token v√†o content/data
    await NotificationService.createPersonalNotification({
      title: `You have an invitation`,
      content: `You have been invited to join workspace "${workspace.name}"`,
      type: 'workspace_invite',
      targetUserId: user._id,
      targetWorkspaceId: workspace._id,
      createdBy: inviterId,
      // Truy·ªÅn th√™m invitationToken v√†o data (n·∫øu NotificationService h·ªó tr·ª£)
      invitationToken: token,
    });

    // 8. Ph·∫£n h·ªìi
    res.status(200).json({
      message: 'Successfully invited user to workspace',
      // inviteLink,
      invitationToken: token,
    });
  } catch (err) {
    console.error('Error inviting user to workspace', err);
    res.status(500).json({
      message: 'Error inviting user to workspace',
      error: err.message,
    });
  }
};

// X√°c nh·∫≠n l·ªùi m·ªùi
exports.respondToInvite = async (req, res) => {
  try {
    const { token, action } = req.body;

    if (!token) {
      return res
        .status(400)
        .json({ message: 'Missing token', status: 'invalid' });
    }

    // T√¨m membership theo token
    const membership = await Membership.findOne({ invitationToken: token });
    if (!membership) {
      return res.status(400).json({
        message: 'Invitation is invalid or expired.',
        status: 'invalid',
      });
    }

    // Ki·ªÉm tra user c√≥ kh·ªõp v·ªõi token kh√¥ng
    if (
      req.user._id.toString() !== membership.userId.toString() ||
      req.user.id.toString() !== membership.userId.toString()
    ) {
      return res.status(403).json({
        message: 'You do not have permission to respond to this invitation.',
        status: 'forbidden',
      });
    }

    // Ki·ªÉm tra tr·∫°ng th√°i l·ªùi m·ªùi
    if (membership.invitationStatus === 'accepted') {
      return res.status(409).json({
        message: 'Invitation has already been accepted.',
        status: 'accepted',
      });
    }
    if (membership.invitationStatus !== 'pending') {
      return res.status(409).json({
        message: 'Invitation has already been responded.',
        status: membership.invitationStatus,
      });
    }

    let workspace;
    if (action === 'accept') {
      membership.invitationStatus = 'accepted';
      // C·∫≠p nh·∫≠t workspace.members
      workspace = await Workspace.findById(membership.workspaceId);
      if (workspace) {
        // Tr√°nh th√™m tr√πng membership
        if (!workspace.members.includes(membership._id)) {
          workspace.members.push(membership._id);
          await workspace.save();
        }
      }
    } else if (action === 'decline') {
      membership.invitationStatus = 'declined';
    } else {
      return res
        .status(400)
        .json({ message: 'Invalid action', status: 'invalid_action' });
    }

    membership.invitationToken = undefined;
    await membership.save();

    return res.status(200).json({
      message: `You have ${
        action === 'accept' ? 'accepted' : 'declined'
      } the invitation to join workspace.`,
      status: membership.invitationStatus,
    });
  } catch (err) {
    // Ch·ªâ tr·∫£ v·ªÅ l·ªói 500 cho l·ªói th·ª±c s·ª± b·∫•t ng·ªù
    console.error('Error responding to invite:', err);
    res.status(500).json({
      message: 'Error responding to invite',
      error: err.message,
      status: 'error',
    });
  }
};

/**
 * GET /workspace/:workspaceId/users
 * Return all non‚Äêdeleted, accepted members of a workspace,
 * with basic user info and their workspace‚Äêrole.
 */
exports.getWorkspaceUsers = async (req, res) => {
  try {
    const { workspaceId } = req.params;
    const workspace = await Workspace.findById(workspaceId)
      .populate({
        path: 'members',
        match: { isDeleted: false, invitationStatus: 'accepted' },
        populate: { path: 'userId', select: 'username email fullname avatar' },
      })
      .lean();
    if (!workspace) {
      return res.status(404).json({ message: 'Workspace not found' });
    }

    const users = workspace.members.map((m) => ({
      _id: m.userId._id,
      username: m.userId.username,
      email: m.userId.email,
      fullname: m.userId.fullname,
      avatar: m.userId.avatar,
      role: m.role,
      joinDate: m.createdAt,
    }));

    res.status(200).json({ success: true, users });
  } catch (err) {
    console.error('getWorkspaceUsers error:', err);
    res.status(500).json({ success: false, error: err.message });
  }
};
